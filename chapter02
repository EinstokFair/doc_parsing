- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Добавление переменных и индексации. Понятие lvalue.

Задумаемся о введении переменных в выражения и реализуем это для начала как
для интерпретатора (специфика компилятора будет рассмотрена дальше в курсе).
Нет проблем добавить в распознавание понятие идентификатора; там, где до сих
пор у нас были только числа, разрешим наличие идентификаторов -
буквенно-цифровых последовательностей, начинающихся с буквы. (Традиционно,
знак '_' также считается буквой для этих целей.) Идентификатор является
частным случаем atom в нашей грамматике.

Простейший работающий подход: при вычислении выражения интерпретатор смотрит
в таблицу идентификаторов и, если такой есть, подставляет запомненное за ним
число. (Если идентификатора нет, генерируется ошибка.)
Это соответствует практике языков, где не обязательно объявлять каждую
переменную (Python; BASIC; классический Fortran; JavaScript, Perl, PHP без
так называемого strict-режима; и ещё многие другие).

В таком виде это работает, но не расширяемо на много полезных вариантов
функциональности. Невозможно сделать не скалярную переменную (то есть, одно
значение), а массив или мапу - чтобы можно было писать a[1] или bbx[i,j,k].
Невозможно делать операторы присвоения: нельзя написать "y <- x*2".

(Отвлечёмся: пока что мы почти молчаливо предполагали, что оператор присвоения
обозначен знаком "<-". В мире есть разные традиции; чаще всего он обозначается
знаком "=" (Fortran, C, C++, Java...), но есть традиции и для ":=" (Pascal и
потомки), и для "<-" (R), и есть такие, где присваиваемое выражение - слева,
а то, чему присваивается - справа - "->" в R и Рапира. R, таким образом,
допускает два зеркально симметричных варианта записи операции присвоения. Самый
частый вариант "=" одновременно известен конфликтами с интуитивным и
традиционным для математики "=" для проверки на равенство; в большинстве
случаев тогда используют "==" для равенства (если не жёстко разделяют места,
где могут быть присвоение и сравнение, как в BASIC).  Использование "<-", хоть
и идёт вразрез с большинством, тут помогает устранить такие конфликты. При
переходе на реальные языки учитывайте этот факт и делайте замену на тот
синтаксис присвоения, который принят в конкретном языке.)

Невозможно также сделать присвоение элементу массива - написать "a[1] <-
b[i]".

Все эти проблемы надо лечить. Для этого надо, чтобы само появление
идентификатора ещё не означало немедленное взятие значения. Идентификатор это
пока "нечто", которое может быть источником значения, а может быть приёмником.
И идентификатор массива, который был индексирован, тоже ещё не означает
немедленное взятие значения; это пока только указание на факт индексирования.
Только после определения, мы его читаем (берём текущее значение) или
записываем (заменяем значение), можно выбрать конкретную операцию с ним.

Термин для этого "нечто" был введён Christopher Strachey (в языке CPL, раннем
предшественнике языка C) и называется "lvalue" - сокращение от
"left value", "левое значение" (в смысле - такое, что может стоять слева от
знака присвоения). Оно частично противоположно по смыслу понятию "rvalue" -
значение, которое может стоять справа от знака присвоения, но не обязательно
допускает присвоение. В C++ эта классификация расширена - например, результат
операции сложения это prvalue, у него есть тип и значение, но нельзя ему ничего
присвоить.

Например:

"a"      - lvalue: можно присвоить переменной "a". Оно также rvalue, но
не prvalue.
"a[1]" - lvalue: можно присвоить элементу массива. Оно также rvalue, но не
prvalue.
"a+b"    - не lvalue: нельзя результату операции присвоить значение. Оно rvalue
и prvalue.
"3"      - не lvalue: нельзя константе присвоить значение. Оно rvalue и prvalue.

И lvalue, и rvalue в большинстве языков и случаев применения типизированы (об
этом будет дальше) - какое-то может быть целым числом, какое-то - строкой, или
ещё чем-то из бесконечного множества возможных типов... возможность присвоения
- фактор, независимый от типа. Для языка, компилируемого в машинный код,
lvalue - это, упрощённо говоря, то, у чего есть адрес в памяти. (Упрощённо -
потому, что совершенно необязательно, что значение будет лежать в адресуемой
памяти; оно может находиться, например, в регистре процессора, причём в разных
регистрах в разные моменты своей жизни. Но для данного момента такое упрощение
вполне устраивает.)

Собственно индексацию добавить в синтаксис достаточно просто. Применяем
лексему "[" в качестве признака индексации, вставив правило для этого на
уровень с приоритетом ниже atom, но выше unary и power; новое правило будет
называться primary; primary может быть "совсем неразделимое" (потому и atom),
такое, как константа, идентификатор или выражение в круглых скобках а может
быть индексируемым "нечто" (массив, мапа и т.д.), вызовом функции и так далее.

Например:
"a"             - primary и atom.
"a[1]"          - primary, но не atom; но это atom, задающий индексируемый
объект (массив, мапа...), после которого индексирующее выражение в квадратных скобках.
"f(a,b)"        - primary, но не atom; но это atom, задающий вызываемый объект
(функция, или нечто, что в данном языке можно вызвать как функцию), после
которого список аргументов в круглых скобках.
(Внимание! Мы не вводим функции в грамматике 4. Это резерв на будущее;
на сейчас введение переменных и так достаточно радикально.)

Отсюда начинается: грамматика номер 4; делаем на основании грамматики 2,
меняем некоторые части.

func primary() {
  v <- atom();
  do {
    continuing <- false;
    if (next is "[") {
      skip "[";
      indexer <- expression();
      skip "]";
      v <- indexate(v, indexer);
      continuing <- true;
    }
    //... тут когда-нибудь будет добавляться вызов функции и т.п.
  } while (continuing);
  return v;
}

// atom: две альтернативы для проверки
// по сравнению с грамматикой 2 - добавлены идентификаторы
func atom() {
  if (next is number) { // 4.1
    return parse_and_skip_number();
  }
  if (next is identifier) {
    return parse_identifier();
  }
  if (next is "(") { // 4.2
    skip "(";
    r <- expression();
    skip ")"; // скобка обязана быть, иначе генерируем ошибку
    return r;
  }
}

но самое существенное - что мы уже не можем передавать только значение
выражения (пусть даже с типом); у нас добавляются принципиально новые
сущности. Тот же parse_identifier() вместо взятия значения переменной с этим
идентификатором и возврата полученного числа - должен выдать значение типа
"идентификатор". А арифметические операции должны перед выполнением своей
основной работы превратить свои аргументы просто в числа (из более сложных
сущностей, включая содержимое идентификаторов, индексирований и т.п.)

Для парсера Пратта нужно определить функцию "[".led() действием индексации.

Чтобы можно было тестировать это на реальных примерах, нам надо организовать
возможность в том же примере устанавливать значения переменных и элементов
мап/массивов. Для этого введём в синтаксис последовательность предложений
(statements), каждый из которых будет пока что только присвоением или
определением мапы (см. ниже).
Значением всей последовательности будет значение последнего предложения, если
оно существует (значение есть у выражений, включая те, что содержат
присвоение, но не у определения мапы).
Каждое предложение вводим отдельной строкой, на вход обработчику подаётся
список строк. Переменные вводятся автоматически по факту первого называния, но
мапы потребуют введения предварительным "@defmap"; это произвольное решение,
но соответствующее подходам многих языков, включая BASIC, Python, Fortran
(периода 1960-70-х годов).

test_mtdp_ml_gr04, test_mtdp_re2c_gr04 - реализации такого на основе
рукописного нисходящего парсера. При чтении обратите внимание на то, где мы
получаем rvalue (просто число) из того, где возможно lvalue, а где, наоборот,
не делаем этого.  Для Python такие вещи проще и надёжнее проверять через
isinstance(); для C++ приме́ним dynamic_cast (не самый дешёвый вариант, но
сработает); ну а для других языковых стилей (например, для C с его статической
типизацией) или необходимости максимально эффективно реализовать ценой
читабельности - потребуется держать флаги "какое из значений мы сейчас знаем".

В приведённых реализациях (Python, C++) мы пользуемся общим базовым классом
SemanticValue для значений, возвращаемых отдельными компонентами - чтобы явно
демонстрировать связь классов отдельных вариантов значений (скаляр,
переменная, индексация) и гарантировать исключение, если какая-то
функциональность не реализована (полезно при отладке). Метод getRValue()
получает просто скалярное значение (универсальный для нас float (Python),
double (C++)). Метод assignValue() записывает новое значение; для скаляра
(ScalarSV), который возникает как константа или арифметическая операция, он
неприменим, а для переменной или индексации - выполняет соответствующую запись
в память переменных.

На этом примере начинает быть виден один из факторов, за счёт чего получается
объём компиляторов - много частных случаев, которые надо отслеживать и
обрабатывать.

// vim: set tw=78 et :
