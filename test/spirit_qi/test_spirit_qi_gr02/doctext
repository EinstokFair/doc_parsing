Здесь будем разбирать построение парсера на boost::spirit::qi (по-русски
это читалось бы как "Ци", см. понятие "энергия Ци").

Парсер пишется в общем духе boost поверх C++, с соответствующим отношением
ко всем элементам.

Используем phrase_parse:
https://www.boost.org/doc/libs/1_55_0/libs/spirit/doc/html/spirit/qi/reference/parse_api/iterator_api.html
Это "Iterator based API". Можно было применить и аналогичное "Stream based
API", которое phrase_match. Но у нас каждый вход - завершённая строка,
поэтому идём так. Ну и вариант типа "оно переводит поток в bad, если не
смогло распарсить" как-то не радует.

phrase_parse требует нечто, пригодное для использования как expr, итераторы
старта и стопа последовательности и места для размещения выходных параметров
(в прототипах по ссылке они Attr1 и так далее).
Итераторы - это просто. Выходные параметры обсудим после. Сейчас надо рисовать
expr.

В качестве expr может быть, согласно
https://www.boost.org/doc/libs/1_55_0/libs/spirit/doc/html/spirit/qi/reference/parser_concepts/parser.html
что угодно, что представляется объектом с методами parse и what с требуемой
сигнатурой.

Забегая вперёд: для реализации нам нужна возможность рекурсивной ссылки правил
друг на друга. Со спецификой C++ это легче всего реализуется построением
некоего struct или class, в котором будут заведены элементы, ссылающиеся
один на другой; в этом случае даже не потребуется делать forward-декларации
(делать которые очень неудобно, потому что сложно назвать заранее тип
получившегося поля).
Инициализация в C++11 и сохранение ссылок в результате инициализации делают
это тривиальным, но можно инициализировать и в конструкторе (см. ниже).

Для этого основываемся на примере:
https://www.boost.org/doc/libs/1_55_0/libs/spirit/example/qi/calc_utree.cpp
Тут видно, что структура с правилами наследуется от qi::grammar<...> (точный
набор параметров шаблона см. в примере). Заводится три правила, и в
конструкторе делается их инициализация (присвоением в теле).
Повторим у себя этот подход.

Дальше самое тяжёлое - отработка семантических правил.
На сейчас получается, что есть два варианта, в которых можно присваивать
значение результату всего правила
1) выражениями типа _val = _val + _1, которые неочевидным образом раскрываются
через Boost.Fusion в исполняемый код
2) функциями, которые получают доп. параметры и отрабатывают поиск
переменной-результата согласно этим параметрам (см. код)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-> Примеры в каталогах вида
https://www.boost.org/doc/libs/1_55_0/libs/spirit/example/qi/
расположены в странном порядке, не алфавитном и не по возрастанию сложности.
Учесть это.
-> В семантических правилах, _1 - часто результат разбора правилом
например: double_[push_back(phoenix::ref(v), _1)] (из примера num_list2)
но тут надо внятно описать, зачем этот phoenix
